// Copyright 2017 Peter Kelly <peter@pmkelly.net>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import {
    Model,
    Interface,
    Field,
    Type,
} from "./model";

function typeToString(type: Type): string {
    if (type._kind === "ArrayType")
        return typeToString(type.members) + "[]";
    else
        return type.name;
}

function generateInterfaces(model: Model): string {
    const output: string[] = [];
    for (let i = 0; i < model.interfaces.length; i++) {
        const iface = model.interfaces[i];
        output.push("export interface " + iface.name + " {\n");
        for (const field of iface.fields) {
            const optional = field.optional ? "?" : "";
            const nullable = field.nullable ? " | null" : "";
            const type = typeToString(field.type);
            output.push(`    ${field.name}${optional}: ${type}${nullable};\n`);
        }
        output.push("}\n");
        if (i + 1 < model.interfaces.length)
            output.push("\n");
    }
    return output.join("");
}

function validationExprForType(type: Type): string {
    switch (type._kind) {
        case "ArrayType":
            return "validation.array(" + validationExprForType(type.members) + ")";
        case "NamedType":
            switch (type.name) {
                case "string":
                    return "validation.string";
                case "number":
                    return "validation.number";
                case "boolean":
                    return "validation.boolean";
                default:
                    return type.name;
            }
    }
}

function generateValidationFunctions(model: Model): string {
    const output: string[] = [];
    for (let i = 0; i < model.interfaces.length; i++) {
        const iface = model.interfaces[i];
        output.push("export function " + iface.name + "(obj: any, path?: string): " + iface.name + " {\n");
        output.push("    validation.checkObject(obj, path);\n");
        output.push("    return {\n");
        for (const field of iface.fields) {
            const accessor = `obj.${field.name}`;
            let expr = validationExprForType(field.type);
            if (field.nullable)
                expr = `(${accessor} === null) ? null : ${expr}`;
            if (field.optional)
                expr = `(${accessor} === undefined) ? undefined : ${expr}`;
            output.push(`        ${field.name}: ${expr}(obj.${field.name}, validation.join(path, '${field.name}')),\n`);

        }
        output.push("    }\n");
        output.push("}\n");
        if (i + 1 < model.interfaces.length)
            output.push("\n");
    }
    return output.join("");
}

export function generate(model: Model): string {
    return "/* tslint:disable */\n\n" +
        "// This file was automatically generated by jsonidator. You should\n" +
        "// modify the original model file if you wish to make changes.\n\n" +
        "import * as validation from \"jsonidator\";\n\n" +
        generateInterfaces(model) +
        "\n" +
        generateValidationFunctions(model);
}

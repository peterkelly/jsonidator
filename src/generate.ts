// Copyright 2017 Peter Kelly <peter@pmkelly.net>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const parser: any = require("./model-parser");

export interface Model {
    _kind: "model";
    interfaces: Interface[];
}

export interface Interface {
    _kind: "Interface";
    name: string;
    fields: Field[];
}

export interface Field {
    _kind: "Field";
    name: string;
    optional: boolean;
    nullable: boolean;
    type: Type;
}

export type Type = ArrayType | NamedType;

export interface ArrayType {
    _kind: "ArrayType";
    members: Type;
}

export interface NamedType {
    _kind: "NamedType";
    name: string;
}

function typeToString(type: Type): string {
    if (type._kind === "ArrayType")
        return typeToString(type.members) + "[]";
    else
        return type.name;
}

function generateInterfaces(model: Model): string {
    const output: string[] = [];
    for (let i = 0; i < model.interfaces.length; i++) {
        const iface = model.interfaces[i];
        output.push("export interface " + iface.name + " {\n");
        for (const field of iface.fields) {
            const optional = field.optional ? "?" : "";
            const nullable = field.nullable ? " | null" : "";
            const type = typeToString(field.type);
            output.push(`    ${field.name}${optional}: ${type}${nullable};\n`);
        }
        output.push("}\n");
        if (i + 1 < model.interfaces.length)
            output.push("\n");
    }
    return output.join("");
}

function validationExprForType(type: Type): string {
    switch (type._kind) {
        case "ArrayType":
            return "validation.array(" + validationExprForType(type.members) + ")";
        case "NamedType":
            switch (type.name) {
                case "string":
                    return "validation.string";
                case "number":
                    return "validation.number";
                case "boolean":
                    return "validation.boolean";
                default:
                    return type.name;
            }
    }
}

function generateValidationFunctions(model: Model): string {
    const output: string[] = [];
    for (let i = 0; i < model.interfaces.length; i++) {
        const iface = model.interfaces[i];
        output.push("export function " + iface.name + "(obj: any, path?: string): " + iface.name + " {\n");
        output.push("    validation.checkObject(obj, path);\n");
        // output.push("    path = path || \"\";\n");
        output.push("    return {\n");
        for (const field of iface.fields) {
            const accessor = `obj.${field.name}`;
            let expr = validationExprForType(field.type);
            // if (field.nullable && field.optional)
            //     expr = expr;
            // else if (field.nullable)
            //     expr = `(${field.name} === null) ? null : ${field.name}`;
            // else if (field.optional)
            //     expr = `(${field.name} === undefined) ? undefined : ${field.name}`;
            if (field.nullable)
                expr = `(${accessor} === null) ? null : ${expr}`;
            if (field.optional)
                expr = `(${accessor} === undefined) ? undefined : ${expr}`;


            // output.push("        " + field.name + ": " + expr +
            //     "(obj." + field.name + ", validation.join(path, " + JSON.stringify(field.name) + ")),\n");
            // output.push(`        ${field.name}: ${expr}(obj.${field.name}, validation.join(path, ${JSON.stringify(field.name)})),\n`);

            output.push(`        ${field.name}: ${expr}(obj.${field.name}, validation.join(path, '${field.name}')),\n`);

        }
        // output.push("    };\n");
        output.push("    }\n");
        output.push("}\n");
        if (i + 1 < model.interfaces.length)
            output.push("\n");
    }
    return output.join("");
}

export function generate(model: Model): string {
    return "/* tslint:disable */\n\n" +
        "// This file was automatically generated by jsonidator. You should\n" +
        "// modify the original model file if you wish to make changes.\n\n" +
        "import * as validation from \"jsonidator\";\n\n" +
        generateInterfaces(model) +
        "\n" +
        generateValidationFunctions(model);
}

export function parse(input: string): Model {
    return (<any> parser).parse(input);
}
